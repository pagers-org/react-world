/**
 * Generated by orval v6.17.0 üç∫
 * Do not edit manually.
 * Conduit API
 * Conduit API
 * OpenAPI spec version: 1.0.0
 */
import axios from "axios";
import type { AxiosRequestConfig, AxiosResponse, AxiosError } from "axios";
import { useQuery, useMutation } from "@tanstack/react-query";
import type {
  UseQueryOptions,
  UseMutationOptions,
  QueryFunction,
  MutationFunction,
  UseQueryResult,
  QueryKey,
} from "@tanstack/react-query";
import type {
  UserResponse,
  GenericErrorModel,
  LoginUserRequest,
  NewUserRequest,
  UpdateUserRequest,
  ProfileResponse,
  MultipleArticlesResponse,
  GetArticlesFeedParams,
  GetArticlesParams,
  SingleArticleResponse,
  NewArticleRequest,
  UpdateArticleRequest,
  MultipleCommentsResponse,
  SingleCommentResponse,
  NewCommentRequest,
  TagsResponse,
} from "./models";
import { rest } from "msw";
import { faker } from "@faker-js/faker";

/**
 * Login for existing user
 * @summary Existing user login
 */
export const login = (
  loginUserRequest: LoginUserRequest,
  options?: AxiosRequestConfig,
): Promise<AxiosResponse<UserResponse>> => {
  return axios.post(`/users/login`, loginUserRequest, options);
};

export const getLoginMutationOptions = <
  TError = AxiosError<void | GenericErrorModel>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof login>>,
    TError,
    { data: LoginUserRequest },
    TContext
  >;
  axios?: AxiosRequestConfig;
}): UseMutationOptions<
  Awaited<ReturnType<typeof login>>,
  TError,
  { data: LoginUserRequest },
  TContext
> => {
  const { mutation: mutationOptions, axios: axiosOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof login>>,
    { data: LoginUserRequest }
  > = (props) => {
    const { data } = props ?? {};

    return login(data, axiosOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type LoginMutationResult = NonNullable<
  Awaited<ReturnType<typeof login>>
>;
export type LoginMutationBody = LoginUserRequest;
export type LoginMutationError = AxiosError<void | GenericErrorModel>;

/**
 * @summary Existing user login
 */
export const useLogin = <
  TError = AxiosError<void | GenericErrorModel>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof login>>,
    TError,
    { data: LoginUserRequest },
    TContext
  >;
  axios?: AxiosRequestConfig;
}) => {
  const mutationOptions = getLoginMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * Register a new user
 * @summary Register a new user
 */
export const createUser = (
  newUserRequest: NewUserRequest,
  options?: AxiosRequestConfig,
): Promise<AxiosResponse<UserResponse>> => {
  return axios.post(`/users`, newUserRequest, options);
};

export const getCreateUserMutationOptions = <
  TError = AxiosError<GenericErrorModel>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof createUser>>,
    TError,
    { data: NewUserRequest },
    TContext
  >;
  axios?: AxiosRequestConfig;
}): UseMutationOptions<
  Awaited<ReturnType<typeof createUser>>,
  TError,
  { data: NewUserRequest },
  TContext
> => {
  const { mutation: mutationOptions, axios: axiosOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof createUser>>,
    { data: NewUserRequest }
  > = (props) => {
    const { data } = props ?? {};

    return createUser(data, axiosOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type CreateUserMutationResult = NonNullable<
  Awaited<ReturnType<typeof createUser>>
>;
export type CreateUserMutationBody = NewUserRequest;
export type CreateUserMutationError = AxiosError<GenericErrorModel>;

/**
 * @summary Register a new user
 */
export const useCreateUser = <
  TError = AxiosError<GenericErrorModel>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof createUser>>,
    TError,
    { data: NewUserRequest },
    TContext
  >;
  axios?: AxiosRequestConfig;
}) => {
  const mutationOptions = getCreateUserMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * Gets the currently logged-in user
 * @summary Get current user
 */
export const getCurrentUser = (
  options?: AxiosRequestConfig,
): Promise<AxiosResponse<UserResponse>> => {
  return axios.get(`/user`, options);
};

export const getGetCurrentUserQueryKey = () => [`/user`] as const;

export const getGetCurrentUserQueryOptions = <
  TData = Awaited<ReturnType<typeof getCurrentUser>>,
  TError = AxiosError<void | GenericErrorModel>,
>(options?: {
  query?: UseQueryOptions<
    Awaited<ReturnType<typeof getCurrentUser>>,
    TError,
    TData
  >;
  axios?: AxiosRequestConfig;
}): UseQueryOptions<
  Awaited<ReturnType<typeof getCurrentUser>>,
  TError,
  TData
> & { queryKey: QueryKey } => {
  const { query: queryOptions, axios: axiosOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetCurrentUserQueryKey();

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getCurrentUser>>> = ({
    signal,
  }) => getCurrentUser({ signal, ...axiosOptions });

  return { queryKey, queryFn, ...queryOptions };
};

export type GetCurrentUserQueryResult = NonNullable<
  Awaited<ReturnType<typeof getCurrentUser>>
>;
export type GetCurrentUserQueryError = AxiosError<void | GenericErrorModel>;

/**
 * @summary Get current user
 */
export const useGetCurrentUser = <
  TData = Awaited<ReturnType<typeof getCurrentUser>>,
  TError = AxiosError<void | GenericErrorModel>,
>(options?: {
  query?: UseQueryOptions<
    Awaited<ReturnType<typeof getCurrentUser>>,
    TError,
    TData
  >;
  axios?: AxiosRequestConfig;
}): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const queryOptions = getGetCurrentUserQueryOptions(options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
};

/**
 * Updated user information for current user
 * @summary Update current user
 */
export const updateCurrentUser = (
  updateUserRequest: UpdateUserRequest,
  options?: AxiosRequestConfig,
): Promise<AxiosResponse<UserResponse>> => {
  return axios.put(`/user`, updateUserRequest, options);
};

export const getUpdateCurrentUserMutationOptions = <
  TError = AxiosError<void | GenericErrorModel>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof updateCurrentUser>>,
    TError,
    { data: UpdateUserRequest },
    TContext
  >;
  axios?: AxiosRequestConfig;
}): UseMutationOptions<
  Awaited<ReturnType<typeof updateCurrentUser>>,
  TError,
  { data: UpdateUserRequest },
  TContext
> => {
  const { mutation: mutationOptions, axios: axiosOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof updateCurrentUser>>,
    { data: UpdateUserRequest }
  > = (props) => {
    const { data } = props ?? {};

    return updateCurrentUser(data, axiosOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type UpdateCurrentUserMutationResult = NonNullable<
  Awaited<ReturnType<typeof updateCurrentUser>>
>;
export type UpdateCurrentUserMutationBody = UpdateUserRequest;
export type UpdateCurrentUserMutationError =
  AxiosError<void | GenericErrorModel>;

/**
 * @summary Update current user
 */
export const useUpdateCurrentUser = <
  TError = AxiosError<void | GenericErrorModel>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof updateCurrentUser>>,
    TError,
    { data: UpdateUserRequest },
    TContext
  >;
  axios?: AxiosRequestConfig;
}) => {
  const mutationOptions = getUpdateCurrentUserMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * Get a profile of a user of the system. Auth is optional
 * @summary Get a profile
 */
export const getProfileByUsername = (
  username: string,
  options?: AxiosRequestConfig,
): Promise<AxiosResponse<ProfileResponse>> => {
  return axios.get(`/profiles/${username}`, options);
};

export const getGetProfileByUsernameQueryKey = (username: string) =>
  [`/profiles/${username}`] as const;

export const getGetProfileByUsernameQueryOptions = <
  TData = Awaited<ReturnType<typeof getProfileByUsername>>,
  TError = AxiosError<void | GenericErrorModel>,
>(
  username: string,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof getProfileByUsername>>,
      TError,
      TData
    >;
    axios?: AxiosRequestConfig;
  },
): UseQueryOptions<
  Awaited<ReturnType<typeof getProfileByUsername>>,
  TError,
  TData
> & { queryKey: QueryKey } => {
  const { query: queryOptions, axios: axiosOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getGetProfileByUsernameQueryKey(username);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getProfileByUsername>>
  > = ({ signal }) =>
    getProfileByUsername(username, { signal, ...axiosOptions });

  return { queryKey, queryFn, enabled: !!username, ...queryOptions };
};

export type GetProfileByUsernameQueryResult = NonNullable<
  Awaited<ReturnType<typeof getProfileByUsername>>
>;
export type GetProfileByUsernameQueryError =
  AxiosError<void | GenericErrorModel>;

/**
 * @summary Get a profile
 */
export const useGetProfileByUsername = <
  TData = Awaited<ReturnType<typeof getProfileByUsername>>,
  TError = AxiosError<void | GenericErrorModel>,
>(
  username: string,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof getProfileByUsername>>,
      TError,
      TData
    >;
    axios?: AxiosRequestConfig;
  },
): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const queryOptions = getGetProfileByUsernameQueryOptions(username, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
};

/**
 * Follow a user by username
 * @summary Follow a user
 */
export const followUserByUsername = (
  username: string,
  options?: AxiosRequestConfig,
): Promise<AxiosResponse<ProfileResponse>> => {
  return axios.post(`/profiles/${username}/follow`, undefined, options);
};

export const getFollowUserByUsernameMutationOptions = <
  TError = AxiosError<void | GenericErrorModel>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof followUserByUsername>>,
    TError,
    { username: string },
    TContext
  >;
  axios?: AxiosRequestConfig;
}): UseMutationOptions<
  Awaited<ReturnType<typeof followUserByUsername>>,
  TError,
  { username: string },
  TContext
> => {
  const { mutation: mutationOptions, axios: axiosOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof followUserByUsername>>,
    { username: string }
  > = (props) => {
    const { username } = props ?? {};

    return followUserByUsername(username, axiosOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type FollowUserByUsernameMutationResult = NonNullable<
  Awaited<ReturnType<typeof followUserByUsername>>
>;

export type FollowUserByUsernameMutationError =
  AxiosError<void | GenericErrorModel>;

/**
 * @summary Follow a user
 */
export const useFollowUserByUsername = <
  TError = AxiosError<void | GenericErrorModel>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof followUserByUsername>>,
    TError,
    { username: string },
    TContext
  >;
  axios?: AxiosRequestConfig;
}) => {
  const mutationOptions = getFollowUserByUsernameMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * Unfollow a user by username
 * @summary Unfollow a user
 */
export const unfollowUserByUsername = (
  username: string,
  options?: AxiosRequestConfig,
): Promise<AxiosResponse<ProfileResponse>> => {
  return axios.delete(`/profiles/${username}/follow`, options);
};

export const getUnfollowUserByUsernameMutationOptions = <
  TError = AxiosError<void | GenericErrorModel>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof unfollowUserByUsername>>,
    TError,
    { username: string },
    TContext
  >;
  axios?: AxiosRequestConfig;
}): UseMutationOptions<
  Awaited<ReturnType<typeof unfollowUserByUsername>>,
  TError,
  { username: string },
  TContext
> => {
  const { mutation: mutationOptions, axios: axiosOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof unfollowUserByUsername>>,
    { username: string }
  > = (props) => {
    const { username } = props ?? {};

    return unfollowUserByUsername(username, axiosOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type UnfollowUserByUsernameMutationResult = NonNullable<
  Awaited<ReturnType<typeof unfollowUserByUsername>>
>;

export type UnfollowUserByUsernameMutationError =
  AxiosError<void | GenericErrorModel>;

/**
 * @summary Unfollow a user
 */
export const useUnfollowUserByUsername = <
  TError = AxiosError<void | GenericErrorModel>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof unfollowUserByUsername>>,
    TError,
    { username: string },
    TContext
  >;
  axios?: AxiosRequestConfig;
}) => {
  const mutationOptions = getUnfollowUserByUsernameMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * Get most recent articles from users you follow. Use query parameters to limit. Auth is required
 * @summary Get recent articles from users you follow
 */
export const getArticlesFeed = (
  params?: GetArticlesFeedParams,
  options?: AxiosRequestConfig,
): Promise<AxiosResponse<MultipleArticlesResponse>> => {
  return axios.get(`/articles/feed`, {
    ...options,
    params: { ...params, ...options?.params },
  });
};

export const getGetArticlesFeedQueryKey = (params?: GetArticlesFeedParams) =>
  [`/articles/feed`, ...(params ? [params] : [])] as const;

export const getGetArticlesFeedQueryOptions = <
  TData = Awaited<ReturnType<typeof getArticlesFeed>>,
  TError = AxiosError<void | GenericErrorModel>,
>(
  params?: GetArticlesFeedParams,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof getArticlesFeed>>,
      TError,
      TData
    >;
    axios?: AxiosRequestConfig;
  },
): UseQueryOptions<
  Awaited<ReturnType<typeof getArticlesFeed>>,
  TError,
  TData
> & { queryKey: QueryKey } => {
  const { query: queryOptions, axios: axiosOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetArticlesFeedQueryKey(params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getArticlesFeed>>> = ({
    signal,
  }) => getArticlesFeed(params, { signal, ...axiosOptions });

  return { queryKey, queryFn, ...queryOptions };
};

export type GetArticlesFeedQueryResult = NonNullable<
  Awaited<ReturnType<typeof getArticlesFeed>>
>;
export type GetArticlesFeedQueryError = AxiosError<void | GenericErrorModel>;

/**
 * @summary Get recent articles from users you follow
 */
export const useGetArticlesFeed = <
  TData = Awaited<ReturnType<typeof getArticlesFeed>>,
  TError = AxiosError<void | GenericErrorModel>,
>(
  params?: GetArticlesFeedParams,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof getArticlesFeed>>,
      TError,
      TData
    >;
    axios?: AxiosRequestConfig;
  },
): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const queryOptions = getGetArticlesFeedQueryOptions(params, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
};

/**
 * Get most recent articles globally. Use query parameters to filter results. Auth is optional
 * @summary Get recent articles globally
 */
export const getArticles = (
  params?: GetArticlesParams,
  options?: AxiosRequestConfig,
): Promise<AxiosResponse<MultipleArticlesResponse>> => {
  return axios.get(`/articles`, {
    ...options,
    params: { ...params, ...options?.params },
  });
};

export const getGetArticlesQueryKey = (params?: GetArticlesParams) =>
  [`/articles`, ...(params ? [params] : [])] as const;

export const getGetArticlesQueryOptions = <
  TData = Awaited<ReturnType<typeof getArticles>>,
  TError = AxiosError<void | GenericErrorModel>,
>(
  params?: GetArticlesParams,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof getArticles>>,
      TError,
      TData
    >;
    axios?: AxiosRequestConfig;
  },
): UseQueryOptions<Awaited<ReturnType<typeof getArticles>>, TError, TData> & {
  queryKey: QueryKey;
} => {
  const { query: queryOptions, axios: axiosOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetArticlesQueryKey(params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getArticles>>> = ({
    signal,
  }) => getArticles(params, { signal, ...axiosOptions });

  return { queryKey, queryFn, ...queryOptions };
};

export type GetArticlesQueryResult = NonNullable<
  Awaited<ReturnType<typeof getArticles>>
>;
export type GetArticlesQueryError = AxiosError<void | GenericErrorModel>;

/**
 * @summary Get recent articles globally
 */
export const useGetArticles = <
  TData = Awaited<ReturnType<typeof getArticles>>,
  TError = AxiosError<void | GenericErrorModel>,
>(
  params?: GetArticlesParams,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof getArticles>>,
      TError,
      TData
    >;
    axios?: AxiosRequestConfig;
  },
): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const queryOptions = getGetArticlesQueryOptions(params, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
};

/**
 * Create an article. Auth is required
 * @summary Create an article
 */
export const createArticle = (
  newArticleRequest: NewArticleRequest,
  options?: AxiosRequestConfig,
): Promise<AxiosResponse<SingleArticleResponse>> => {
  return axios.post(`/articles`, newArticleRequest, options);
};

export const getCreateArticleMutationOptions = <
  TError = AxiosError<void | GenericErrorModel>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof createArticle>>,
    TError,
    { data: NewArticleRequest },
    TContext
  >;
  axios?: AxiosRequestConfig;
}): UseMutationOptions<
  Awaited<ReturnType<typeof createArticle>>,
  TError,
  { data: NewArticleRequest },
  TContext
> => {
  const { mutation: mutationOptions, axios: axiosOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof createArticle>>,
    { data: NewArticleRequest }
  > = (props) => {
    const { data } = props ?? {};

    return createArticle(data, axiosOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type CreateArticleMutationResult = NonNullable<
  Awaited<ReturnType<typeof createArticle>>
>;
export type CreateArticleMutationBody = NewArticleRequest;
export type CreateArticleMutationError = AxiosError<void | GenericErrorModel>;

/**
 * @summary Create an article
 */
export const useCreateArticle = <
  TError = AxiosError<void | GenericErrorModel>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof createArticle>>,
    TError,
    { data: NewArticleRequest },
    TContext
  >;
  axios?: AxiosRequestConfig;
}) => {
  const mutationOptions = getCreateArticleMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * Get an article. Auth not required
 * @summary Get an article
 */
export const getArticle = (
  slug: string,
  options?: AxiosRequestConfig,
): Promise<AxiosResponse<SingleArticleResponse>> => {
  return axios.get(`/articles/${slug}`, options);
};

export const getGetArticleQueryKey = (slug: string) =>
  [`/articles/${slug}`] as const;

export const getGetArticleQueryOptions = <
  TData = Awaited<ReturnType<typeof getArticle>>,
  TError = AxiosError<GenericErrorModel>,
>(
  slug: string,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof getArticle>>,
      TError,
      TData
    >;
    axios?: AxiosRequestConfig;
  },
): UseQueryOptions<Awaited<ReturnType<typeof getArticle>>, TError, TData> & {
  queryKey: QueryKey;
} => {
  const { query: queryOptions, axios: axiosOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetArticleQueryKey(slug);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getArticle>>> = ({
    signal,
  }) => getArticle(slug, { signal, ...axiosOptions });

  return { queryKey, queryFn, enabled: !!slug, ...queryOptions };
};

export type GetArticleQueryResult = NonNullable<
  Awaited<ReturnType<typeof getArticle>>
>;
export type GetArticleQueryError = AxiosError<GenericErrorModel>;

/**
 * @summary Get an article
 */
export const useGetArticle = <
  TData = Awaited<ReturnType<typeof getArticle>>,
  TError = AxiosError<GenericErrorModel>,
>(
  slug: string,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof getArticle>>,
      TError,
      TData
    >;
    axios?: AxiosRequestConfig;
  },
): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const queryOptions = getGetArticleQueryOptions(slug, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
};

/**
 * Update an article. Auth is required
 * @summary Update an article
 */
export const updateArticle = (
  slug: string,
  updateArticleRequest: UpdateArticleRequest,
  options?: AxiosRequestConfig,
): Promise<AxiosResponse<SingleArticleResponse>> => {
  return axios.put(`/articles/${slug}`, updateArticleRequest, options);
};

export const getUpdateArticleMutationOptions = <
  TError = AxiosError<void | GenericErrorModel>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof updateArticle>>,
    TError,
    { slug: string; data: UpdateArticleRequest },
    TContext
  >;
  axios?: AxiosRequestConfig;
}): UseMutationOptions<
  Awaited<ReturnType<typeof updateArticle>>,
  TError,
  { slug: string; data: UpdateArticleRequest },
  TContext
> => {
  const { mutation: mutationOptions, axios: axiosOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof updateArticle>>,
    { slug: string; data: UpdateArticleRequest }
  > = (props) => {
    const { slug, data } = props ?? {};

    return updateArticle(slug, data, axiosOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type UpdateArticleMutationResult = NonNullable<
  Awaited<ReturnType<typeof updateArticle>>
>;
export type UpdateArticleMutationBody = UpdateArticleRequest;
export type UpdateArticleMutationError = AxiosError<void | GenericErrorModel>;

/**
 * @summary Update an article
 */
export const useUpdateArticle = <
  TError = AxiosError<void | GenericErrorModel>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof updateArticle>>,
    TError,
    { slug: string; data: UpdateArticleRequest },
    TContext
  >;
  axios?: AxiosRequestConfig;
}) => {
  const mutationOptions = getUpdateArticleMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * Delete an article. Auth is required
 * @summary Delete an article
 */
export const deleteArticle = (
  slug: string,
  options?: AxiosRequestConfig,
): Promise<AxiosResponse<void>> => {
  return axios.delete(`/articles/${slug}`, options);
};

export const getDeleteArticleMutationOptions = <
  TError = AxiosError<GenericErrorModel>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof deleteArticle>>,
    TError,
    { slug: string },
    TContext
  >;
  axios?: AxiosRequestConfig;
}): UseMutationOptions<
  Awaited<ReturnType<typeof deleteArticle>>,
  TError,
  { slug: string },
  TContext
> => {
  const { mutation: mutationOptions, axios: axiosOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof deleteArticle>>,
    { slug: string }
  > = (props) => {
    const { slug } = props ?? {};

    return deleteArticle(slug, axiosOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type DeleteArticleMutationResult = NonNullable<
  Awaited<ReturnType<typeof deleteArticle>>
>;

export type DeleteArticleMutationError = AxiosError<GenericErrorModel>;

/**
 * @summary Delete an article
 */
export const useDeleteArticle = <
  TError = AxiosError<GenericErrorModel>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof deleteArticle>>,
    TError,
    { slug: string },
    TContext
  >;
  axios?: AxiosRequestConfig;
}) => {
  const mutationOptions = getDeleteArticleMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * Get the comments for an article. Auth is optional
 * @summary Get comments for an article
 */
export const getArticleComments = (
  slug: string,
  options?: AxiosRequestConfig,
): Promise<AxiosResponse<MultipleCommentsResponse>> => {
  return axios.get(`/articles/${slug}/comments`, options);
};

export const getGetArticleCommentsQueryKey = (slug: string) =>
  [`/articles/${slug}/comments`] as const;

export const getGetArticleCommentsQueryOptions = <
  TData = Awaited<ReturnType<typeof getArticleComments>>,
  TError = AxiosError<void | GenericErrorModel>,
>(
  slug: string,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof getArticleComments>>,
      TError,
      TData
    >;
    axios?: AxiosRequestConfig;
  },
): UseQueryOptions<
  Awaited<ReturnType<typeof getArticleComments>>,
  TError,
  TData
> & { queryKey: QueryKey } => {
  const { query: queryOptions, axios: axiosOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getGetArticleCommentsQueryKey(slug);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getArticleComments>>
  > = ({ signal }) => getArticleComments(slug, { signal, ...axiosOptions });

  return { queryKey, queryFn, enabled: !!slug, ...queryOptions };
};

export type GetArticleCommentsQueryResult = NonNullable<
  Awaited<ReturnType<typeof getArticleComments>>
>;
export type GetArticleCommentsQueryError = AxiosError<void | GenericErrorModel>;

/**
 * @summary Get comments for an article
 */
export const useGetArticleComments = <
  TData = Awaited<ReturnType<typeof getArticleComments>>,
  TError = AxiosError<void | GenericErrorModel>,
>(
  slug: string,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof getArticleComments>>,
      TError,
      TData
    >;
    axios?: AxiosRequestConfig;
  },
): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const queryOptions = getGetArticleCommentsQueryOptions(slug, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
};

/**
 * Create a comment for an article. Auth is required
 * @summary Create a comment for an article
 */
export const createArticleComment = (
  slug: string,
  newCommentRequest: NewCommentRequest,
  options?: AxiosRequestConfig,
): Promise<AxiosResponse<SingleCommentResponse>> => {
  return axios.post(`/articles/${slug}/comments`, newCommentRequest, options);
};

export const getCreateArticleCommentMutationOptions = <
  TError = AxiosError<void | GenericErrorModel>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof createArticleComment>>,
    TError,
    { slug: string; data: NewCommentRequest },
    TContext
  >;
  axios?: AxiosRequestConfig;
}): UseMutationOptions<
  Awaited<ReturnType<typeof createArticleComment>>,
  TError,
  { slug: string; data: NewCommentRequest },
  TContext
> => {
  const { mutation: mutationOptions, axios: axiosOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof createArticleComment>>,
    { slug: string; data: NewCommentRequest }
  > = (props) => {
    const { slug, data } = props ?? {};

    return createArticleComment(slug, data, axiosOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type CreateArticleCommentMutationResult = NonNullable<
  Awaited<ReturnType<typeof createArticleComment>>
>;
export type CreateArticleCommentMutationBody = NewCommentRequest;
export type CreateArticleCommentMutationError =
  AxiosError<void | GenericErrorModel>;

/**
 * @summary Create a comment for an article
 */
export const useCreateArticleComment = <
  TError = AxiosError<void | GenericErrorModel>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof createArticleComment>>,
    TError,
    { slug: string; data: NewCommentRequest },
    TContext
  >;
  axios?: AxiosRequestConfig;
}) => {
  const mutationOptions = getCreateArticleCommentMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * Delete a comment for an article. Auth is required
 * @summary Delete a comment for an article
 */
export const deleteArticleComment = (
  slug: string,
  id: number,
  options?: AxiosRequestConfig,
): Promise<AxiosResponse<void>> => {
  return axios.delete(`/articles/${slug}/comments/${id}`, options);
};

export const getDeleteArticleCommentMutationOptions = <
  TError = AxiosError<GenericErrorModel>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof deleteArticleComment>>,
    TError,
    { slug: string; id: number },
    TContext
  >;
  axios?: AxiosRequestConfig;
}): UseMutationOptions<
  Awaited<ReturnType<typeof deleteArticleComment>>,
  TError,
  { slug: string; id: number },
  TContext
> => {
  const { mutation: mutationOptions, axios: axiosOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof deleteArticleComment>>,
    { slug: string; id: number }
  > = (props) => {
    const { slug, id } = props ?? {};

    return deleteArticleComment(slug, id, axiosOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type DeleteArticleCommentMutationResult = NonNullable<
  Awaited<ReturnType<typeof deleteArticleComment>>
>;

export type DeleteArticleCommentMutationError = AxiosError<GenericErrorModel>;

/**
 * @summary Delete a comment for an article
 */
export const useDeleteArticleComment = <
  TError = AxiosError<GenericErrorModel>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof deleteArticleComment>>,
    TError,
    { slug: string; id: number },
    TContext
  >;
  axios?: AxiosRequestConfig;
}) => {
  const mutationOptions = getDeleteArticleCommentMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * Favorite an article. Auth is required
 * @summary Favorite an article
 */
export const createArticleFavorite = (
  slug: string,
  options?: AxiosRequestConfig,
): Promise<AxiosResponse<SingleArticleResponse>> => {
  return axios.post(`/articles/${slug}/favorite`, undefined, options);
};

export const getCreateArticleFavoriteMutationOptions = <
  TError = AxiosError<void | GenericErrorModel>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof createArticleFavorite>>,
    TError,
    { slug: string },
    TContext
  >;
  axios?: AxiosRequestConfig;
}): UseMutationOptions<
  Awaited<ReturnType<typeof createArticleFavorite>>,
  TError,
  { slug: string },
  TContext
> => {
  const { mutation: mutationOptions, axios: axiosOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof createArticleFavorite>>,
    { slug: string }
  > = (props) => {
    const { slug } = props ?? {};

    return createArticleFavorite(slug, axiosOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type CreateArticleFavoriteMutationResult = NonNullable<
  Awaited<ReturnType<typeof createArticleFavorite>>
>;

export type CreateArticleFavoriteMutationError =
  AxiosError<void | GenericErrorModel>;

/**
 * @summary Favorite an article
 */
export const useCreateArticleFavorite = <
  TError = AxiosError<void | GenericErrorModel>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof createArticleFavorite>>,
    TError,
    { slug: string },
    TContext
  >;
  axios?: AxiosRequestConfig;
}) => {
  const mutationOptions = getCreateArticleFavoriteMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * Unfavorite an article. Auth is required
 * @summary Unfavorite an article
 */
export const deleteArticleFavorite = (
  slug: string,
  options?: AxiosRequestConfig,
): Promise<AxiosResponse<SingleArticleResponse>> => {
  return axios.delete(`/articles/${slug}/favorite`, options);
};

export const getDeleteArticleFavoriteMutationOptions = <
  TError = AxiosError<void | GenericErrorModel>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof deleteArticleFavorite>>,
    TError,
    { slug: string },
    TContext
  >;
  axios?: AxiosRequestConfig;
}): UseMutationOptions<
  Awaited<ReturnType<typeof deleteArticleFavorite>>,
  TError,
  { slug: string },
  TContext
> => {
  const { mutation: mutationOptions, axios: axiosOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof deleteArticleFavorite>>,
    { slug: string }
  > = (props) => {
    const { slug } = props ?? {};

    return deleteArticleFavorite(slug, axiosOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type DeleteArticleFavoriteMutationResult = NonNullable<
  Awaited<ReturnType<typeof deleteArticleFavorite>>
>;

export type DeleteArticleFavoriteMutationError =
  AxiosError<void | GenericErrorModel>;

/**
 * @summary Unfavorite an article
 */
export const useDeleteArticleFavorite = <
  TError = AxiosError<void | GenericErrorModel>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof deleteArticleFavorite>>,
    TError,
    { slug: string },
    TContext
  >;
  axios?: AxiosRequestConfig;
}) => {
  const mutationOptions = getDeleteArticleFavoriteMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * Get tags. Auth not required
 * @summary Get tags
 */
export const getTags = (
  options?: AxiosRequestConfig,
): Promise<AxiosResponse<TagsResponse>> => {
  return axios.get(`/tags`, options);
};

export const getGetTagsQueryKey = () => [`/tags`] as const;

export const getGetTagsQueryOptions = <
  TData = Awaited<ReturnType<typeof getTags>>,
  TError = AxiosError<GenericErrorModel>,
>(options?: {
  query?: UseQueryOptions<Awaited<ReturnType<typeof getTags>>, TError, TData>;
  axios?: AxiosRequestConfig;
}): UseQueryOptions<Awaited<ReturnType<typeof getTags>>, TError, TData> & {
  queryKey: QueryKey;
} => {
  const { query: queryOptions, axios: axiosOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetTagsQueryKey();

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getTags>>> = ({
    signal,
  }) => getTags({ signal, ...axiosOptions });

  return { queryKey, queryFn, ...queryOptions };
};

export type GetTagsQueryResult = NonNullable<
  Awaited<ReturnType<typeof getTags>>
>;
export type GetTagsQueryError = AxiosError<GenericErrorModel>;

/**
 * @summary Get tags
 */
export const useGetTags = <
  TData = Awaited<ReturnType<typeof getTags>>,
  TError = AxiosError<GenericErrorModel>,
>(options?: {
  query?: UseQueryOptions<Awaited<ReturnType<typeof getTags>>, TError, TData>;
  axios?: AxiosRequestConfig;
}): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const queryOptions = getGetTagsQueryOptions(options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
};

export const getLoginMock = () => ({
  user: {
    email: faker.random.word(),
    token: faker.random.word(),
    username: faker.random.word(),
    bio: faker.random.word(),
    image: faker.random.word(),
  },
});

export const getCreateUserMock = () => ({
  user: {
    email: faker.random.word(),
    token: faker.random.word(),
    username: faker.random.word(),
    bio: faker.random.word(),
    image: faker.random.word(),
  },
});

export const getGetCurrentUserMock = () => ({
  user: {
    email: faker.random.word(),
    token: faker.random.word(),
    username: faker.random.word(),
    bio: faker.random.word(),
    image: faker.random.word(),
  },
});

export const getUpdateCurrentUserMock = () => ({
  user: {
    email: faker.random.word(),
    token: faker.random.word(),
    username: faker.random.word(),
    bio: faker.random.word(),
    image: faker.random.word(),
  },
});

export const getGetProfileByUsernameMock = () => ({
  profile: {
    username: faker.random.word(),
    bio: faker.random.word(),
    image: faker.random.word(),
    following: faker.datatype.boolean(),
  },
});

export const getFollowUserByUsernameMock = () => ({
  profile: {
    username: faker.random.word(),
    bio: faker.random.word(),
    image: faker.random.word(),
    following: faker.datatype.boolean(),
  },
});

export const getUnfollowUserByUsernameMock = () => ({
  profile: {
    username: faker.random.word(),
    bio: faker.random.word(),
    image: faker.random.word(),
    following: faker.datatype.boolean(),
  },
});

export const getGetArticlesFeedMock = () => ({
  articles: Array.from(
    { length: faker.datatype.number({ min: 1, max: 10 }) },
    (_, i) => i + 1,
  ).map(() => ({
    slug: faker.random.word(),
    title: faker.random.word(),
    description: faker.random.word(),
    body: faker.random.word(),
    tagList: Array.from(
      { length: faker.datatype.number({ min: 1, max: 10 }) },
      (_, i) => i + 1,
    ).map(() => faker.random.word()),
    createdAt: `${faker.date.past().toISOString().split(".")[0]}Z`,
    updatedAt: `${faker.date.past().toISOString().split(".")[0]}Z`,
    favorited: faker.datatype.boolean(),
    favoritesCount: faker.datatype.number({ min: undefined, max: undefined }),
    author: {
      username: faker.random.word(),
      bio: faker.random.word(),
      image: faker.random.word(),
      following: faker.datatype.boolean(),
    },
  })),
  articlesCount: faker.datatype.number({ min: undefined, max: undefined }),
});

export const getGetArticlesMock = () => ({
  articles: Array.from(
    { length: faker.datatype.number({ min: 1, max: 10 }) },
    (_, i) => i + 1,
  ).map(() => ({
    slug: faker.random.word(),
    title: faker.random.word(),
    description: faker.random.word(),
    body: faker.random.word(),
    tagList: Array.from(
      { length: faker.datatype.number({ min: 1, max: 10 }) },
      (_, i) => i + 1,
    ).map(() => faker.random.word()),
    createdAt: `${faker.date.past().toISOString().split(".")[0]}Z`,
    updatedAt: `${faker.date.past().toISOString().split(".")[0]}Z`,
    favorited: faker.datatype.boolean(),
    favoritesCount: faker.datatype.number({ min: undefined, max: undefined }),
    author: {
      username: faker.random.word(),
      bio: faker.random.word(),
      image: faker.random.word(),
      following: faker.datatype.boolean(),
    },
  })),
  articlesCount: faker.datatype.number({ min: undefined, max: undefined }),
});

export const getCreateArticleMock = () => ({
  article: {
    slug: faker.random.word(),
    title: faker.random.word(),
    description: faker.random.word(),
    body: faker.random.word(),
    tagList: Array.from(
      { length: faker.datatype.number({ min: 1, max: 10 }) },
      (_, i) => i + 1,
    ).map(() => faker.random.word()),
    createdAt: `${faker.date.past().toISOString().split(".")[0]}Z`,
    updatedAt: `${faker.date.past().toISOString().split(".")[0]}Z`,
    favorited: faker.datatype.boolean(),
    favoritesCount: faker.datatype.number({ min: undefined, max: undefined }),
    author: {
      username: faker.random.word(),
      bio: faker.random.word(),
      image: faker.random.word(),
      following: faker.datatype.boolean(),
    },
  },
});

export const getGetArticleMock = () => ({
  article: {
    slug: faker.random.word(),
    title: faker.random.word(),
    description: faker.random.word(),
    body: faker.random.word(),
    tagList: Array.from(
      { length: faker.datatype.number({ min: 1, max: 10 }) },
      (_, i) => i + 1,
    ).map(() => faker.random.word()),
    createdAt: `${faker.date.past().toISOString().split(".")[0]}Z`,
    updatedAt: `${faker.date.past().toISOString().split(".")[0]}Z`,
    favorited: faker.datatype.boolean(),
    favoritesCount: faker.datatype.number({ min: undefined, max: undefined }),
    author: {
      username: faker.random.word(),
      bio: faker.random.word(),
      image: faker.random.word(),
      following: faker.datatype.boolean(),
    },
  },
});

export const getUpdateArticleMock = () => ({
  article: {
    slug: faker.random.word(),
    title: faker.random.word(),
    description: faker.random.word(),
    body: faker.random.word(),
    tagList: Array.from(
      { length: faker.datatype.number({ min: 1, max: 10 }) },
      (_, i) => i + 1,
    ).map(() => faker.random.word()),
    createdAt: `${faker.date.past().toISOString().split(".")[0]}Z`,
    updatedAt: `${faker.date.past().toISOString().split(".")[0]}Z`,
    favorited: faker.datatype.boolean(),
    favoritesCount: faker.datatype.number({ min: undefined, max: undefined }),
    author: {
      username: faker.random.word(),
      bio: faker.random.word(),
      image: faker.random.word(),
      following: faker.datatype.boolean(),
    },
  },
});

export const getGetArticleCommentsMock = () => ({
  comments: Array.from(
    { length: faker.datatype.number({ min: 1, max: 10 }) },
    (_, i) => i + 1,
  ).map(() => ({
    id: faker.datatype.number({ min: undefined, max: undefined }),
    createdAt: `${faker.date.past().toISOString().split(".")[0]}Z`,
    updatedAt: `${faker.date.past().toISOString().split(".")[0]}Z`,
    body: faker.random.word(),
    author: {
      username: faker.random.word(),
      bio: faker.random.word(),
      image: faker.random.word(),
      following: faker.datatype.boolean(),
    },
  })),
});

export const getCreateArticleCommentMock = () => ({
  comment: {
    id: faker.datatype.number({ min: undefined, max: undefined }),
    createdAt: `${faker.date.past().toISOString().split(".")[0]}Z`,
    updatedAt: `${faker.date.past().toISOString().split(".")[0]}Z`,
    body: faker.random.word(),
    author: {
      username: faker.random.word(),
      bio: faker.random.word(),
      image: faker.random.word(),
      following: faker.datatype.boolean(),
    },
  },
});

export const getCreateArticleFavoriteMock = () => ({
  article: {
    slug: faker.random.word(),
    title: faker.random.word(),
    description: faker.random.word(),
    body: faker.random.word(),
    tagList: Array.from(
      { length: faker.datatype.number({ min: 1, max: 10 }) },
      (_, i) => i + 1,
    ).map(() => faker.random.word()),
    createdAt: `${faker.date.past().toISOString().split(".")[0]}Z`,
    updatedAt: `${faker.date.past().toISOString().split(".")[0]}Z`,
    favorited: faker.datatype.boolean(),
    favoritesCount: faker.datatype.number({ min: undefined, max: undefined }),
    author: {
      username: faker.random.word(),
      bio: faker.random.word(),
      image: faker.random.word(),
      following: faker.datatype.boolean(),
    },
  },
});

export const getDeleteArticleFavoriteMock = () => ({
  article: {
    slug: faker.random.word(),
    title: faker.random.word(),
    description: faker.random.word(),
    body: faker.random.word(),
    tagList: Array.from(
      { length: faker.datatype.number({ min: 1, max: 10 }) },
      (_, i) => i + 1,
    ).map(() => faker.random.word()),
    createdAt: `${faker.date.past().toISOString().split(".")[0]}Z`,
    updatedAt: `${faker.date.past().toISOString().split(".")[0]}Z`,
    favorited: faker.datatype.boolean(),
    favoritesCount: faker.datatype.number({ min: undefined, max: undefined }),
    author: {
      username: faker.random.word(),
      bio: faker.random.word(),
      image: faker.random.word(),
      following: faker.datatype.boolean(),
    },
  },
});

export const getGetTagsMock = () => ({
  tags: Array.from(
    { length: faker.datatype.number({ min: 1, max: 10 }) },
    (_, i) => i + 1,
  ).map(() => faker.random.word()),
});

export const getConduitAPIMSW = () => [
  rest.post("*/users/login", (_req, res, ctx) => {
    return res(
      ctx.delay(1000),
      ctx.status(200, "Mocked status"),
      ctx.json(getLoginMock()),
    );
  }),
  rest.post("*/users", (_req, res, ctx) => {
    return res(
      ctx.delay(1000),
      ctx.status(200, "Mocked status"),
      ctx.json(getCreateUserMock()),
    );
  }),
  rest.get("*/user", (_req, res, ctx) => {
    return res(
      ctx.delay(1000),
      ctx.status(200, "Mocked status"),
      ctx.json(getGetCurrentUserMock()),
    );
  }),
  rest.put("*/user", (_req, res, ctx) => {
    return res(
      ctx.delay(1000),
      ctx.status(200, "Mocked status"),
      ctx.json(getUpdateCurrentUserMock()),
    );
  }),
  rest.get("*/profiles/:username", (_req, res, ctx) => {
    return res(
      ctx.delay(1000),
      ctx.status(200, "Mocked status"),
      ctx.json(getGetProfileByUsernameMock()),
    );
  }),
  rest.post("*/profiles/:username/follow", (_req, res, ctx) => {
    return res(
      ctx.delay(1000),
      ctx.status(200, "Mocked status"),
      ctx.json(getFollowUserByUsernameMock()),
    );
  }),
  rest.delete("*/profiles/:username/follow", (_req, res, ctx) => {
    return res(
      ctx.delay(1000),
      ctx.status(200, "Mocked status"),
      ctx.json(getUnfollowUserByUsernameMock()),
    );
  }),
  rest.get("*/articles/feed", (_req, res, ctx) => {
    return res(
      ctx.delay(1000),
      ctx.status(200, "Mocked status"),
      ctx.json(getGetArticlesFeedMock()),
    );
  }),
  rest.get("*/articles", (_req, res, ctx) => {
    return res(
      ctx.delay(1000),
      ctx.status(200, "Mocked status"),
      ctx.json(getGetArticlesMock()),
    );
  }),
  rest.post("*/articles", (_req, res, ctx) => {
    return res(
      ctx.delay(1000),
      ctx.status(200, "Mocked status"),
      ctx.json(getCreateArticleMock()),
    );
  }),
  rest.get("*/articles/:slug", (_req, res, ctx) => {
    return res(
      ctx.delay(1000),
      ctx.status(200, "Mocked status"),
      ctx.json(getGetArticleMock()),
    );
  }),
  rest.put("*/articles/:slug", (_req, res, ctx) => {
    return res(
      ctx.delay(1000),
      ctx.status(200, "Mocked status"),
      ctx.json(getUpdateArticleMock()),
    );
  }),
  rest.delete("*/articles/:slug", (_req, res, ctx) => {
    return res(ctx.delay(1000), ctx.status(200, "Mocked status"));
  }),
  rest.get("*/articles/:slug/comments", (_req, res, ctx) => {
    return res(
      ctx.delay(1000),
      ctx.status(200, "Mocked status"),
      ctx.json(getGetArticleCommentsMock()),
    );
  }),
  rest.post("*/articles/:slug/comments", (_req, res, ctx) => {
    return res(
      ctx.delay(1000),
      ctx.status(200, "Mocked status"),
      ctx.json(getCreateArticleCommentMock()),
    );
  }),
  rest.delete("*/articles/:slug/comments/:id", (_req, res, ctx) => {
    return res(ctx.delay(1000), ctx.status(200, "Mocked status"));
  }),
  rest.post("*/articles/:slug/favorite", (_req, res, ctx) => {
    return res(
      ctx.delay(1000),
      ctx.status(200, "Mocked status"),
      ctx.json(getCreateArticleFavoriteMock()),
    );
  }),
  rest.delete("*/articles/:slug/favorite", (_req, res, ctx) => {
    return res(
      ctx.delay(1000),
      ctx.status(200, "Mocked status"),
      ctx.json(getDeleteArticleFavoriteMock()),
    );
  }),
  rest.get("*/tags", (_req, res, ctx) => {
    return res(
      ctx.delay(1000),
      ctx.status(200, "Mocked status"),
      ctx.json(getGetTagsMock()),
    );
  }),
];
