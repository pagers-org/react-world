/**
 * Generated by orval v6.17.0 üç∫
 * Do not edit manually.
 * Conduit API
 * Conduit API
 * OpenAPI spec version: 1.0.0
 */
import axios from 'axios'
import type {
  AxiosRequestConfig,
  AxiosResponse,
  AxiosError
} from 'axios'
import {
  useQuery,
  useMutation
} from '@tanstack/react-query'
import type {
  UseQueryOptions,
  UseMutationOptions,
  QueryFunction,
  MutationFunction,
  UseQueryResult,
  QueryKey
} from '@tanstack/react-query'
import type {
  UserResponse,
  GenericErrorModel,
  LoginUserRequest,
  NewUserRequest,
  UpdateUserRequest,
  ProfileResponse,
  MultipleArticlesResponse,
  GetArticlesFeedParams,
  GetArticlesParams,
  SingleArticleResponse,
  NewArticleRequest,
  UpdateArticleRequest,
  MultipleCommentsResponse,
  SingleCommentResponse,
  NewCommentRequest,
  TagsResponse
} from './models'



/**
 * Login for existing user
 * @summary Existing user login
 */
export const login = (
    loginUserRequest: LoginUserRequest, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<UserResponse>> => {
    return axios.post(
      `/users/login`,
      loginUserRequest,options
    );
  }



export const getLoginMutationOptions = <TError = AxiosError<void | GenericErrorModel>,
    
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof login>>, TError,{data: LoginUserRequest}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof login>>, TError,{data: LoginUserRequest}, TContext> => {
 const {mutation: mutationOptions, axios: axiosOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof login>>, {data: LoginUserRequest}> = (props) => {
          const {data} = props ?? {};

          return  login(data,axiosOptions)
        }

        

 
   return  { mutationFn, ...mutationOptions }}

    export type LoginMutationResult = NonNullable<Awaited<ReturnType<typeof login>>>
    export type LoginMutationBody = LoginUserRequest
    export type LoginMutationError = AxiosError<void | GenericErrorModel>

    /**
 * @summary Existing user login
 */
export const useLogin = <TError = AxiosError<void | GenericErrorModel>,
    
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof login>>, TError,{data: LoginUserRequest}, TContext>, axios?: AxiosRequestConfig}
) => {
    
      const mutationOptions = getLoginMutationOptions(options);
     
      return useMutation(mutationOptions);
    }
    
/**
 * Register a new user
 * @summary Register a new user
 */
export const createUser = (
    newUserRequest: NewUserRequest, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<UserResponse>> => {
    return axios.post(
      `/users`,
      newUserRequest,options
    );
  }



export const getCreateUserMutationOptions = <TError = AxiosError<GenericErrorModel>,
    
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createUser>>, TError,{data: NewUserRequest}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof createUser>>, TError,{data: NewUserRequest}, TContext> => {
 const {mutation: mutationOptions, axios: axiosOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof createUser>>, {data: NewUserRequest}> = (props) => {
          const {data} = props ?? {};

          return  createUser(data,axiosOptions)
        }

        

 
   return  { mutationFn, ...mutationOptions }}

    export type CreateUserMutationResult = NonNullable<Awaited<ReturnType<typeof createUser>>>
    export type CreateUserMutationBody = NewUserRequest
    export type CreateUserMutationError = AxiosError<GenericErrorModel>

    /**
 * @summary Register a new user
 */
export const useCreateUser = <TError = AxiosError<GenericErrorModel>,
    
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createUser>>, TError,{data: NewUserRequest}, TContext>, axios?: AxiosRequestConfig}
) => {
    
      const mutationOptions = getCreateUserMutationOptions(options);
     
      return useMutation(mutationOptions);
    }
    
/**
 * Gets the currently logged-in user
 * @summary Get current user
 */
export const getCurrentUser = (
     options?: AxiosRequestConfig
 ): Promise<AxiosResponse<UserResponse>> => {
    return axios.get(
      `/user`,options
    );
  }


export const getGetCurrentUserQueryKey = () => [`/user`] as const;
  

    
export const getGetCurrentUserQueryOptions = <TData = Awaited<ReturnType<typeof getCurrentUser>>, TError = AxiosError<void | GenericErrorModel>>( options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getCurrentUser>>, TError, TData>, axios?: AxiosRequestConfig}
): UseQueryOptions<Awaited<ReturnType<typeof getCurrentUser>>, TError, TData> & { queryKey: QueryKey } => {
const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetCurrentUserQueryKey();

  
  
    const queryFn: QueryFunction<Awaited<ReturnType<typeof getCurrentUser>>> = ({ signal }) => getCurrentUser({ signal, ...axiosOptions });
    
      
      
   return  { queryKey, queryFn, ...queryOptions}}

export type GetCurrentUserQueryResult = NonNullable<Awaited<ReturnType<typeof getCurrentUser>>>
export type GetCurrentUserQueryError = AxiosError<void | GenericErrorModel>

/**
 * @summary Get current user
 */
export const useGetCurrentUser = <TData = Awaited<ReturnType<typeof getCurrentUser>>, TError = AxiosError<void | GenericErrorModel>>(
  options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getCurrentUser>>, TError, TData>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getGetCurrentUserQueryOptions(options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}


/**
 * Updated user information for current user
 * @summary Update current user
 */
export const updateCurrentUser = (
    updateUserRequest: UpdateUserRequest, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<UserResponse>> => {
    return axios.put(
      `/user`,
      updateUserRequest,options
    );
  }



export const getUpdateCurrentUserMutationOptions = <TError = AxiosError<void | GenericErrorModel>,
    
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateCurrentUser>>, TError,{data: UpdateUserRequest}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof updateCurrentUser>>, TError,{data: UpdateUserRequest}, TContext> => {
 const {mutation: mutationOptions, axios: axiosOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updateCurrentUser>>, {data: UpdateUserRequest}> = (props) => {
          const {data} = props ?? {};

          return  updateCurrentUser(data,axiosOptions)
        }

        

 
   return  { mutationFn, ...mutationOptions }}

    export type UpdateCurrentUserMutationResult = NonNullable<Awaited<ReturnType<typeof updateCurrentUser>>>
    export type UpdateCurrentUserMutationBody = UpdateUserRequest
    export type UpdateCurrentUserMutationError = AxiosError<void | GenericErrorModel>

    /**
 * @summary Update current user
 */
export const useUpdateCurrentUser = <TError = AxiosError<void | GenericErrorModel>,
    
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateCurrentUser>>, TError,{data: UpdateUserRequest}, TContext>, axios?: AxiosRequestConfig}
) => {
    
      const mutationOptions = getUpdateCurrentUserMutationOptions(options);
     
      return useMutation(mutationOptions);
    }
    
/**
 * Get a profile of a user of the system. Auth is optional
 * @summary Get a profile
 */
export const getProfileByUsername = (
    username: string, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<ProfileResponse>> => {
    return axios.get(
      `/profiles/${username}`,options
    );
  }


export const getGetProfileByUsernameQueryKey = (username: string,) => [`/profiles/${username}`] as const;
  

    
export const getGetProfileByUsernameQueryOptions = <TData = Awaited<ReturnType<typeof getProfileByUsername>>, TError = AxiosError<void | GenericErrorModel>>(username: string, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getProfileByUsername>>, TError, TData>, axios?: AxiosRequestConfig}
): UseQueryOptions<Awaited<ReturnType<typeof getProfileByUsername>>, TError, TData> & { queryKey: QueryKey } => {
const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetProfileByUsernameQueryKey(username);

  
  
    const queryFn: QueryFunction<Awaited<ReturnType<typeof getProfileByUsername>>> = ({ signal }) => getProfileByUsername(username, { signal, ...axiosOptions });
    
      
      
   return  { queryKey, queryFn, enabled: !!(username), ...queryOptions}}

export type GetProfileByUsernameQueryResult = NonNullable<Awaited<ReturnType<typeof getProfileByUsername>>>
export type GetProfileByUsernameQueryError = AxiosError<void | GenericErrorModel>

/**
 * @summary Get a profile
 */
export const useGetProfileByUsername = <TData = Awaited<ReturnType<typeof getProfileByUsername>>, TError = AxiosError<void | GenericErrorModel>>(
 username: string, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getProfileByUsername>>, TError, TData>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getGetProfileByUsernameQueryOptions(username,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}


/**
 * Follow a user by username
 * @summary Follow a user
 */
export const followUserByUsername = (
    username: string, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<ProfileResponse>> => {
    return axios.post(
      `/profiles/${username}/follow`,undefined,options
    );
  }



export const getFollowUserByUsernameMutationOptions = <TError = AxiosError<void | GenericErrorModel>,
    
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof followUserByUsername>>, TError,{username: string}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof followUserByUsername>>, TError,{username: string}, TContext> => {
 const {mutation: mutationOptions, axios: axiosOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof followUserByUsername>>, {username: string}> = (props) => {
          const {username} = props ?? {};

          return  followUserByUsername(username,axiosOptions)
        }

        

 
   return  { mutationFn, ...mutationOptions }}

    export type FollowUserByUsernameMutationResult = NonNullable<Awaited<ReturnType<typeof followUserByUsername>>>
    
    export type FollowUserByUsernameMutationError = AxiosError<void | GenericErrorModel>

    /**
 * @summary Follow a user
 */
export const useFollowUserByUsername = <TError = AxiosError<void | GenericErrorModel>,
    
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof followUserByUsername>>, TError,{username: string}, TContext>, axios?: AxiosRequestConfig}
) => {
    
      const mutationOptions = getFollowUserByUsernameMutationOptions(options);
     
      return useMutation(mutationOptions);
    }
    
/**
 * Unfollow a user by username
 * @summary Unfollow a user
 */
export const unfollowUserByUsername = (
    username: string, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<ProfileResponse>> => {
    return axios.delete(
      `/profiles/${username}/follow`,options
    );
  }



export const getUnfollowUserByUsernameMutationOptions = <TError = AxiosError<void | GenericErrorModel>,
    
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof unfollowUserByUsername>>, TError,{username: string}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof unfollowUserByUsername>>, TError,{username: string}, TContext> => {
 const {mutation: mutationOptions, axios: axiosOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof unfollowUserByUsername>>, {username: string}> = (props) => {
          const {username} = props ?? {};

          return  unfollowUserByUsername(username,axiosOptions)
        }

        

 
   return  { mutationFn, ...mutationOptions }}

    export type UnfollowUserByUsernameMutationResult = NonNullable<Awaited<ReturnType<typeof unfollowUserByUsername>>>
    
    export type UnfollowUserByUsernameMutationError = AxiosError<void | GenericErrorModel>

    /**
 * @summary Unfollow a user
 */
export const useUnfollowUserByUsername = <TError = AxiosError<void | GenericErrorModel>,
    
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof unfollowUserByUsername>>, TError,{username: string}, TContext>, axios?: AxiosRequestConfig}
) => {
    
      const mutationOptions = getUnfollowUserByUsernameMutationOptions(options);
     
      return useMutation(mutationOptions);
    }
    
/**
 * Get most recent articles from users you follow. Use query parameters to limit. Auth is required
 * @summary Get recent articles from users you follow
 */
export const getArticlesFeed = (
    params?: GetArticlesFeedParams, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<MultipleArticlesResponse>> => {
    return axios.get(
      `/articles/feed`,{
    ...options,
        params: {...params, ...options?.params},}
    );
  }


export const getGetArticlesFeedQueryKey = (params?: GetArticlesFeedParams,) => [`/articles/feed`, ...(params ? [params]: [])] as const;
  

    
export const getGetArticlesFeedQueryOptions = <TData = Awaited<ReturnType<typeof getArticlesFeed>>, TError = AxiosError<void | GenericErrorModel>>(params?: GetArticlesFeedParams, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getArticlesFeed>>, TError, TData>, axios?: AxiosRequestConfig}
): UseQueryOptions<Awaited<ReturnType<typeof getArticlesFeed>>, TError, TData> & { queryKey: QueryKey } => {
const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetArticlesFeedQueryKey(params);

  
  
    const queryFn: QueryFunction<Awaited<ReturnType<typeof getArticlesFeed>>> = ({ signal }) => getArticlesFeed(params, { signal, ...axiosOptions });
    
      
      
   return  { queryKey, queryFn, ...queryOptions}}

export type GetArticlesFeedQueryResult = NonNullable<Awaited<ReturnType<typeof getArticlesFeed>>>
export type GetArticlesFeedQueryError = AxiosError<void | GenericErrorModel>

/**
 * @summary Get recent articles from users you follow
 */
export const useGetArticlesFeed = <TData = Awaited<ReturnType<typeof getArticlesFeed>>, TError = AxiosError<void | GenericErrorModel>>(
 params?: GetArticlesFeedParams, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getArticlesFeed>>, TError, TData>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getGetArticlesFeedQueryOptions(params,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}


/**
 * Get most recent articles globally. Use query parameters to filter results. Auth is optional
 * @summary Get recent articles globally
 */
export const getArticles = (
    params?: GetArticlesParams, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<MultipleArticlesResponse>> => {
    return axios.get(
      `/articles`,{
    ...options,
        params: {...params, ...options?.params},}
    );
  }


export const getGetArticlesQueryKey = (params?: GetArticlesParams,) => [`/articles`, ...(params ? [params]: [])] as const;
  

    
export const getGetArticlesQueryOptions = <TData = Awaited<ReturnType<typeof getArticles>>, TError = AxiosError<void | GenericErrorModel>>(params?: GetArticlesParams, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getArticles>>, TError, TData>, axios?: AxiosRequestConfig}
): UseQueryOptions<Awaited<ReturnType<typeof getArticles>>, TError, TData> & { queryKey: QueryKey } => {
const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetArticlesQueryKey(params);

  
  
    const queryFn: QueryFunction<Awaited<ReturnType<typeof getArticles>>> = ({ signal }) => getArticles(params, { signal, ...axiosOptions });
    
      
      
   return  { queryKey, queryFn, ...queryOptions}}

export type GetArticlesQueryResult = NonNullable<Awaited<ReturnType<typeof getArticles>>>
export type GetArticlesQueryError = AxiosError<void | GenericErrorModel>

/**
 * @summary Get recent articles globally
 */
export const useGetArticles = <TData = Awaited<ReturnType<typeof getArticles>>, TError = AxiosError<void | GenericErrorModel>>(
 params?: GetArticlesParams, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getArticles>>, TError, TData>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getGetArticlesQueryOptions(params,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}


/**
 * Create an article. Auth is required
 * @summary Create an article
 */
export const createArticle = (
    newArticleRequest: NewArticleRequest, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<SingleArticleResponse>> => {
    return axios.post(
      `/articles`,
      newArticleRequest,options
    );
  }



export const getCreateArticleMutationOptions = <TError = AxiosError<void | GenericErrorModel>,
    
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createArticle>>, TError,{data: NewArticleRequest}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof createArticle>>, TError,{data: NewArticleRequest}, TContext> => {
 const {mutation: mutationOptions, axios: axiosOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof createArticle>>, {data: NewArticleRequest}> = (props) => {
          const {data} = props ?? {};

          return  createArticle(data,axiosOptions)
        }

        

 
   return  { mutationFn, ...mutationOptions }}

    export type CreateArticleMutationResult = NonNullable<Awaited<ReturnType<typeof createArticle>>>
    export type CreateArticleMutationBody = NewArticleRequest
    export type CreateArticleMutationError = AxiosError<void | GenericErrorModel>

    /**
 * @summary Create an article
 */
export const useCreateArticle = <TError = AxiosError<void | GenericErrorModel>,
    
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createArticle>>, TError,{data: NewArticleRequest}, TContext>, axios?: AxiosRequestConfig}
) => {
    
      const mutationOptions = getCreateArticleMutationOptions(options);
     
      return useMutation(mutationOptions);
    }
    
/**
 * Get an article. Auth not required
 * @summary Get an article
 */
export const getArticle = (
    slug: string, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<SingleArticleResponse>> => {
    return axios.get(
      `/articles/${slug}`,options
    );
  }


export const getGetArticleQueryKey = (slug: string,) => [`/articles/${slug}`] as const;
  

    
export const getGetArticleQueryOptions = <TData = Awaited<ReturnType<typeof getArticle>>, TError = AxiosError<GenericErrorModel>>(slug: string, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getArticle>>, TError, TData>, axios?: AxiosRequestConfig}
): UseQueryOptions<Awaited<ReturnType<typeof getArticle>>, TError, TData> & { queryKey: QueryKey } => {
const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetArticleQueryKey(slug);

  
  
    const queryFn: QueryFunction<Awaited<ReturnType<typeof getArticle>>> = ({ signal }) => getArticle(slug, { signal, ...axiosOptions });
    
      
      
   return  { queryKey, queryFn, enabled: !!(slug), ...queryOptions}}

export type GetArticleQueryResult = NonNullable<Awaited<ReturnType<typeof getArticle>>>
export type GetArticleQueryError = AxiosError<GenericErrorModel>

/**
 * @summary Get an article
 */
export const useGetArticle = <TData = Awaited<ReturnType<typeof getArticle>>, TError = AxiosError<GenericErrorModel>>(
 slug: string, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getArticle>>, TError, TData>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getGetArticleQueryOptions(slug,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}


/**
 * Update an article. Auth is required
 * @summary Update an article
 */
export const updateArticle = (
    slug: string,
    updateArticleRequest: UpdateArticleRequest, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<SingleArticleResponse>> => {
    return axios.put(
      `/articles/${slug}`,
      updateArticleRequest,options
    );
  }



export const getUpdateArticleMutationOptions = <TError = AxiosError<void | GenericErrorModel>,
    
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateArticle>>, TError,{slug: string;data: UpdateArticleRequest}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof updateArticle>>, TError,{slug: string;data: UpdateArticleRequest}, TContext> => {
 const {mutation: mutationOptions, axios: axiosOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updateArticle>>, {slug: string;data: UpdateArticleRequest}> = (props) => {
          const {slug,data} = props ?? {};

          return  updateArticle(slug,data,axiosOptions)
        }

        

 
   return  { mutationFn, ...mutationOptions }}

    export type UpdateArticleMutationResult = NonNullable<Awaited<ReturnType<typeof updateArticle>>>
    export type UpdateArticleMutationBody = UpdateArticleRequest
    export type UpdateArticleMutationError = AxiosError<void | GenericErrorModel>

    /**
 * @summary Update an article
 */
export const useUpdateArticle = <TError = AxiosError<void | GenericErrorModel>,
    
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateArticle>>, TError,{slug: string;data: UpdateArticleRequest}, TContext>, axios?: AxiosRequestConfig}
) => {
    
      const mutationOptions = getUpdateArticleMutationOptions(options);
     
      return useMutation(mutationOptions);
    }
    
/**
 * Delete an article. Auth is required
 * @summary Delete an article
 */
export const deleteArticle = (
    slug: string, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    return axios.delete(
      `/articles/${slug}`,options
    );
  }



export const getDeleteArticleMutationOptions = <TError = AxiosError<GenericErrorModel>,
    
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteArticle>>, TError,{slug: string}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof deleteArticle>>, TError,{slug: string}, TContext> => {
 const {mutation: mutationOptions, axios: axiosOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteArticle>>, {slug: string}> = (props) => {
          const {slug} = props ?? {};

          return  deleteArticle(slug,axiosOptions)
        }

        

 
   return  { mutationFn, ...mutationOptions }}

    export type DeleteArticleMutationResult = NonNullable<Awaited<ReturnType<typeof deleteArticle>>>
    
    export type DeleteArticleMutationError = AxiosError<GenericErrorModel>

    /**
 * @summary Delete an article
 */
export const useDeleteArticle = <TError = AxiosError<GenericErrorModel>,
    
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteArticle>>, TError,{slug: string}, TContext>, axios?: AxiosRequestConfig}
) => {
    
      const mutationOptions = getDeleteArticleMutationOptions(options);
     
      return useMutation(mutationOptions);
    }
    
/**
 * Get the comments for an article. Auth is optional
 * @summary Get comments for an article
 */
export const getArticleComments = (
    slug: string, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<MultipleCommentsResponse>> => {
    return axios.get(
      `/articles/${slug}/comments`,options
    );
  }


export const getGetArticleCommentsQueryKey = (slug: string,) => [`/articles/${slug}/comments`] as const;
  

    
export const getGetArticleCommentsQueryOptions = <TData = Awaited<ReturnType<typeof getArticleComments>>, TError = AxiosError<void | GenericErrorModel>>(slug: string, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getArticleComments>>, TError, TData>, axios?: AxiosRequestConfig}
): UseQueryOptions<Awaited<ReturnType<typeof getArticleComments>>, TError, TData> & { queryKey: QueryKey } => {
const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetArticleCommentsQueryKey(slug);

  
  
    const queryFn: QueryFunction<Awaited<ReturnType<typeof getArticleComments>>> = ({ signal }) => getArticleComments(slug, { signal, ...axiosOptions });
    
      
      
   return  { queryKey, queryFn, enabled: !!(slug), ...queryOptions}}

export type GetArticleCommentsQueryResult = NonNullable<Awaited<ReturnType<typeof getArticleComments>>>
export type GetArticleCommentsQueryError = AxiosError<void | GenericErrorModel>

/**
 * @summary Get comments for an article
 */
export const useGetArticleComments = <TData = Awaited<ReturnType<typeof getArticleComments>>, TError = AxiosError<void | GenericErrorModel>>(
 slug: string, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getArticleComments>>, TError, TData>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getGetArticleCommentsQueryOptions(slug,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}


/**
 * Create a comment for an article. Auth is required
 * @summary Create a comment for an article
 */
export const createArticleComment = (
    slug: string,
    newCommentRequest: NewCommentRequest, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<SingleCommentResponse>> => {
    return axios.post(
      `/articles/${slug}/comments`,
      newCommentRequest,options
    );
  }



export const getCreateArticleCommentMutationOptions = <TError = AxiosError<void | GenericErrorModel>,
    
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createArticleComment>>, TError,{slug: string;data: NewCommentRequest}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof createArticleComment>>, TError,{slug: string;data: NewCommentRequest}, TContext> => {
 const {mutation: mutationOptions, axios: axiosOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof createArticleComment>>, {slug: string;data: NewCommentRequest}> = (props) => {
          const {slug,data} = props ?? {};

          return  createArticleComment(slug,data,axiosOptions)
        }

        

 
   return  { mutationFn, ...mutationOptions }}

    export type CreateArticleCommentMutationResult = NonNullable<Awaited<ReturnType<typeof createArticleComment>>>
    export type CreateArticleCommentMutationBody = NewCommentRequest
    export type CreateArticleCommentMutationError = AxiosError<void | GenericErrorModel>

    /**
 * @summary Create a comment for an article
 */
export const useCreateArticleComment = <TError = AxiosError<void | GenericErrorModel>,
    
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createArticleComment>>, TError,{slug: string;data: NewCommentRequest}, TContext>, axios?: AxiosRequestConfig}
) => {
    
      const mutationOptions = getCreateArticleCommentMutationOptions(options);
     
      return useMutation(mutationOptions);
    }
    
/**
 * Delete a comment for an article. Auth is required
 * @summary Delete a comment for an article
 */
export const deleteArticleComment = (
    slug: string,
    id: number, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    return axios.delete(
      `/articles/${slug}/comments/${id}`,options
    );
  }



export const getDeleteArticleCommentMutationOptions = <TError = AxiosError<GenericErrorModel>,
    
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteArticleComment>>, TError,{slug: string;id: number}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof deleteArticleComment>>, TError,{slug: string;id: number}, TContext> => {
 const {mutation: mutationOptions, axios: axiosOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteArticleComment>>, {slug: string;id: number}> = (props) => {
          const {slug,id} = props ?? {};

          return  deleteArticleComment(slug,id,axiosOptions)
        }

        

 
   return  { mutationFn, ...mutationOptions }}

    export type DeleteArticleCommentMutationResult = NonNullable<Awaited<ReturnType<typeof deleteArticleComment>>>
    
    export type DeleteArticleCommentMutationError = AxiosError<GenericErrorModel>

    /**
 * @summary Delete a comment for an article
 */
export const useDeleteArticleComment = <TError = AxiosError<GenericErrorModel>,
    
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteArticleComment>>, TError,{slug: string;id: number}, TContext>, axios?: AxiosRequestConfig}
) => {
    
      const mutationOptions = getDeleteArticleCommentMutationOptions(options);
     
      return useMutation(mutationOptions);
    }
    
/**
 * Favorite an article. Auth is required
 * @summary Favorite an article
 */
export const createArticleFavorite = (
    slug: string, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<SingleArticleResponse>> => {
    return axios.post(
      `/articles/${slug}/favorite`,undefined,options
    );
  }



export const getCreateArticleFavoriteMutationOptions = <TError = AxiosError<void | GenericErrorModel>,
    
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createArticleFavorite>>, TError,{slug: string}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof createArticleFavorite>>, TError,{slug: string}, TContext> => {
 const {mutation: mutationOptions, axios: axiosOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof createArticleFavorite>>, {slug: string}> = (props) => {
          const {slug} = props ?? {};

          return  createArticleFavorite(slug,axiosOptions)
        }

        

 
   return  { mutationFn, ...mutationOptions }}

    export type CreateArticleFavoriteMutationResult = NonNullable<Awaited<ReturnType<typeof createArticleFavorite>>>
    
    export type CreateArticleFavoriteMutationError = AxiosError<void | GenericErrorModel>

    /**
 * @summary Favorite an article
 */
export const useCreateArticleFavorite = <TError = AxiosError<void | GenericErrorModel>,
    
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createArticleFavorite>>, TError,{slug: string}, TContext>, axios?: AxiosRequestConfig}
) => {
    
      const mutationOptions = getCreateArticleFavoriteMutationOptions(options);
     
      return useMutation(mutationOptions);
    }
    
/**
 * Unfavorite an article. Auth is required
 * @summary Unfavorite an article
 */
export const deleteArticleFavorite = (
    slug: string, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<SingleArticleResponse>> => {
    return axios.delete(
      `/articles/${slug}/favorite`,options
    );
  }



export const getDeleteArticleFavoriteMutationOptions = <TError = AxiosError<void | GenericErrorModel>,
    
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteArticleFavorite>>, TError,{slug: string}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof deleteArticleFavorite>>, TError,{slug: string}, TContext> => {
 const {mutation: mutationOptions, axios: axiosOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteArticleFavorite>>, {slug: string}> = (props) => {
          const {slug} = props ?? {};

          return  deleteArticleFavorite(slug,axiosOptions)
        }

        

 
   return  { mutationFn, ...mutationOptions }}

    export type DeleteArticleFavoriteMutationResult = NonNullable<Awaited<ReturnType<typeof deleteArticleFavorite>>>
    
    export type DeleteArticleFavoriteMutationError = AxiosError<void | GenericErrorModel>

    /**
 * @summary Unfavorite an article
 */
export const useDeleteArticleFavorite = <TError = AxiosError<void | GenericErrorModel>,
    
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteArticleFavorite>>, TError,{slug: string}, TContext>, axios?: AxiosRequestConfig}
) => {
    
      const mutationOptions = getDeleteArticleFavoriteMutationOptions(options);
     
      return useMutation(mutationOptions);
    }
    
/**
 * Get tags. Auth not required
 * @summary Get tags
 */
export const getTags = (
     options?: AxiosRequestConfig
 ): Promise<AxiosResponse<TagsResponse>> => {
    return axios.get(
      `/tags`,options
    );
  }


export const getGetTagsQueryKey = () => [`/tags`] as const;
  

    
export const getGetTagsQueryOptions = <TData = Awaited<ReturnType<typeof getTags>>, TError = AxiosError<GenericErrorModel>>( options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getTags>>, TError, TData>, axios?: AxiosRequestConfig}
): UseQueryOptions<Awaited<ReturnType<typeof getTags>>, TError, TData> & { queryKey: QueryKey } => {
const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetTagsQueryKey();

  
  
    const queryFn: QueryFunction<Awaited<ReturnType<typeof getTags>>> = ({ signal }) => getTags({ signal, ...axiosOptions });
    
      
      
   return  { queryKey, queryFn, ...queryOptions}}

export type GetTagsQueryResult = NonNullable<Awaited<ReturnType<typeof getTags>>>
export type GetTagsQueryError = AxiosError<GenericErrorModel>

/**
 * @summary Get tags
 */
export const useGetTags = <TData = Awaited<ReturnType<typeof getTags>>, TError = AxiosError<GenericErrorModel>>(
  options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getTags>>, TError, TData>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getGetTagsQueryOptions(options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}


